package io.collap.bryg.compiler.ast.expression;

import bryg.org.objectweb.asm.Label;
import io.collap.bryg.compiler.ast.expression.bool.BooleanExpression;
import io.collap.bryg.compiler.ast.expression.bool.ExpressionBooleanExpression;
import io.collap.bryg.compiler.context.Context;
import io.collap.bryg.exception.BrygJitException;
import io.collap.bryg.parser.BrygParser;

import javax.annotation.Nullable;

public class ArgumentExpression extends Expression {

    private @Nullable String name;

    private Expression expression;

    /**
     * The argument is skipped if the predicate is false.
     */
    private @Nullable BooleanExpression predicate;

    public ArgumentExpression (Context context, BrygParser.ArgumentContext ctx) {
        super (context);
        setLine (ctx.getStart ().getLine ());

        BrygParser.ArgumentIdContext id = ctx.argumentId ();
        if (id != null) {
            name = id.getText ();
        }

        expression = (Expression) context.getParseTreeVisitor ().visit (ctx.expression ());

        if (expression.getType ().equals (Void.TYPE)) {
            throw new BrygJitException ("An argument expression must not return void.", getLine ());
        }

        setType (expression.getType ());

        /* Check for predicate. */
        BrygParser.ArgumentPredicateContext predicateContext = ctx.argumentPredicate ();
        if (predicateContext != null) {
            Expression predicateExpression = (Expression) context.getParseTreeVisitor ().visit (predicateContext);
            // TODO: Automate this "node boxing".
            if (predicateExpression instanceof BooleanExpression) {
                predicate = (BooleanExpression) predicateExpression;
            }else {
                predicate = new ExpressionBooleanExpression (context, predicateExpression);
            }
        }else {
            predicate = null;
        }
    }

    @Override
    public void compile () {
        expression.compile ();
    }

    /**
     * The generated bytecode is supposed to be executed right before the argument is handled.
     * @return A label that is supposed to stand after the execution of the argument handling code.
     *         Returns null if no predicate exists.
     */
    public @Nullable Label compilePredicate () {
        if (predicate == null) {
            return null;
        }

        Label nextFalseLabel = new Label ();
        Label nextTrueLabel = new Label ();

        /* Compile the boolean expression, which jumps if necessary. */
        predicate.compile (nextFalseLabel, nextTrueLabel, true);

        context.getMethodVisitor ().visitLabel (nextTrueLabel);
        return nextFalseLabel;
    }

    public @Nullable String getName () {
        return name;
    }

    @Override
    public Object getConstantValue () {
        return expression.getConstantValue ();
    }

    public Expression getExpression () {
        return expression;
    }

    public @Nullable BooleanExpression getPredicate () {
        return predicate;
    }

}
